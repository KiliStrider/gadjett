["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "],"~$Infinity",["^ "],"~$Function",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$gadjett.collections","~:imports",null,"~:requires",["^ ","~$clojure.set","^>","~$clojure.walk","^?","~$clojure.string","^@","~$zip","~$clojure.zip","^B","^B"],"~:uses",["^ ","~$postwalk","^?","~$union","^>","~$join","^@","~$split-lines","^@","~$blank?","^@"],"~:defs",["^ ","~$unflatten-keys",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^;","~:line",485,"~:column",7,"~:end-line",485,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^S",[["~$m"]]]]],"~:doc","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"^:","~$gadjett.collections/unflatten-keys","~:variadic",false,"^M","gadjett/collections.cljc","^Q",21,"~:method-params",["^S",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^S",[null,null]],"^O",1,"^N",485,"^P",485,"~:max-fixed-arity",1,"~:fn-var",true,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"~$sequence->map",["^ ","^K",null,"^L",["^ ","^M","^;","^N",136,"^O",7,"^P",136,"^Q",20,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"^:","~$gadjett.collections/sequence->map","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["~$s"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",136,"^P",136,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"~$=without-keys?",["^ ","^K",null,"^L",["^ ","^M","^;","^N",37,"^O",7,"^P",37,"^Q",21,"^R",["^S",["^T",["^S",[["~$obj-a","~$obj-b","~$keys-list"]]]]],"^U","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"^:","~$gadjett.collections/=without-keys?","^W",false,"^M","gadjett/collections.cljc","^Q",21,"^X",["^S",[["^14","^15","^16"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",37,"^P",37,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["^14","^15","^16"]]]]],"^U","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"~$dissoc-in",["^ ","^K",null,"^L",["^ ","^M","^;","^N",340,"^O",7,"^P",340,"^Q",16,"^R",["^S",["^T",["^S",[["~$m",["~$k","~$&","~$ks","~:as","~$keys"]]]]]],"^U","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"^:","~$gadjett.collections/dissoc-in","^W",false,"^M","gadjett/collections.cljc","^Q",16,"^X",["^S",[["~$m","~$p__220"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",340,"^P",340,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$m",["~$k","~$&","^19","^1:","^1;"]]]]]],"^U","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"~$split-by-predicate-positions",["^ ","^K",null,"^L",["^ ","^M","^;","^N",396,"^O",7,"^P",396,"^Q",35,"^R",["^S",["^T",["^S",[["~$coll","~$pred","~$n","~$d"]]]]],"^U","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"^:","~$gadjett.collections/split-by-predicate-positions","^W",false,"^M","gadjett/collections.cljc","^Q",35,"^X",["^S",[["^1?","^1@","~$n","~$d"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",396,"^P",396,"^[",4,"^10",true,"^R",["^S",["^T",["^S",[["^1?","^1@","~$n","~$d"]]]]],"^U","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"~$mapify",["^ ","^K",null,"^L",["^ ","^M","^;","^N",317,"^O",7,"^P",317,"^Q",13,"^R",["^S",["^T",["^S",[["~$f","~$s"]]]]],"^U","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"^:","~$gadjett.collections/mapify","^W",false,"^M","gadjett/collections.cljc","^Q",13,"^X",["^S",[["~$f","~$s"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",317,"^P",317,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$f","~$s"]]]]],"^U","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"~$submap?",["^ ","^K",null,"^L",["^ ","^M","^;","^N",429,"^O",7,"^P",429,"^Q",14,"^R",["^S",["^T",["^S",[["~$m1","~$m2"]]]]],"^U","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"^:","~$gadjett.collections/submap?","^W",false,"^M","gadjett/collections.cljc","^Q",14,"^X",["^S",[["^1E","^1F"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",429,"^P",429,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^1E","^1F"]]]]],"^U","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"~$positions",["^ ","^K",null,"^L",["^ ","^M","^;","^N",365,"^O",7,"^P",365,"^Q",16,"^R",["^S",["^T",["^S",[["~$coll-of-lengths","~$&",["^ ","~:keys",["~$max-val","~$first-val"],"~:or",["^ ","^1K","~$infinity","^1L",0]]]]]]],"^U","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  ","~:top-fn",["^ ","^W",true,"^[",1,"^X",[["^S",["^1I",["^ ","^1J",["^1K","^1L"],"^1M",["^ ","^1K","^1N","^1L",0]]]]],"^R",["^S",[["^1I","~$&",["^ ","^1J",["^1K","^1L"],"^1M",["^ ","^1K","^1N","^1L",0]]]]],"^Z",["^S",[null]]]],"^:","~$gadjett.collections/positions","^W",true,"^M","gadjett/collections.cljc","^Q",16,"^1O",["^ ","^W",true,"^[",1,"^X",[["^S",["^1I",["^ ","^1J",["^1K","^1L"],"^1M",["^ ","^1K","^1N","^1L",0]]]]],"^R",["^S",[["^1I","~$&",["^ ","^1J",["^1K","^1L"],"^1M",["^ ","^1K","^1N","^1L",0]]]]],"^Z",["^S",[null]]],"^X",[["^S",["^1I",["^ ","^1J",["^1K","^1L"],"^1M",["^ ","^1K","^1N","^1L",0]]]]],"^Y",null,"^Z",["^S",[null]],"^O",1,"^N",365,"^P",365,"^[",1,"^10",true,"^R",["^S",[["^1I","~$&",["^ ","^1J",["^1K","^1L"],"^1M",["^ ","^1K","^1N","^1L",0]]]]],"^U","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  "],"~$filter-map",["^ ","^K",null,"^L",["^ ","^M","^;","^N",267,"^O",7,"^P",267,"^Q",17,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/filter-map","^W",false,"^M","gadjett/collections.cljc","^Q",17,"^X",["^S",[["~$f","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",267,"^P",267,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"~$vec->map",["^ ","^K",null,"^L",["^ ","^M","^;","^N",47,"^O",7,"^P",47,"^Q",15,"^R",["^S",["^T",["^S",[["~$vec"]]]]],"^U","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"^:","~$gadjett.collections/vec->map","^W",false,"^M","gadjett/collections.cljc","^Q",15,"^X",["^S",[["^1T"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",47,"^P",47,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["^1T"]]]]],"^U","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"~$assoc-cyclic",["^ ","^K",null,"^L",["^ ","^M","^;","^N",205,"^O",7,"^P",205,"^Q",19,"^R",["^S",["^T",["^S",[["^1?","~$k","~$v"],["^1?","~$k","~$v","~$n"]]]]],"^U","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  ","^1O",["^ ","^W",false,"^[",4,"^X",["^S",[["^1?","~$k","~$v"],["^1?","~$k","~$v","~$n"]]],"^R",["^S",[["^1?","~$k","~$v"],["^1?","~$k","~$v","~$n"]]],"^Z",["^S",[null,null]]]],"^:","~$gadjett.collections/assoc-cyclic","^W",false,"^M","gadjett/collections.cljc","^Q",19,"^1O",["^ ","^W",false,"^[",4,"^X",["^S",[["^1?","~$k","~$v"],["^1?","~$k","~$v","~$n"]]],"^R",["^S",[["^1?","~$k","~$v"],["^1?","~$k","~$v","~$n"]]],"^Z",["^S",[null,null]]],"^X",["^S",[["^1?","~$k","~$v"],["^1?","~$k","~$v","~$n"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",205,"^P",205,"^[",4,"^10",true,"^R",["^S",[["^1?","~$k","~$v"],["^1?","~$k","~$v","~$n"]]],"^U","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  "],"^1N",["^ ","^:","~$gadjett.collections/infinity","^M","gadjett/collections.cljc","^N",7,"^O",1,"^P",7,"^Q",14,"^L",["^ ","^M","^;","^N",7,"^O",6,"^P",7,"^Q",14],"~:tag","~$js"],"~$subsequence",["^ ","^K",null,"^L",["^ ","^M","^;","^N",444,"^O",7,"^P",444,"^Q",18,"^R",["^S",["^T",["^S",[["^1?","~$start","~$end"]]]]],"^U","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"^:","~$gadjett.collections/subsequence","^W",false,"^M","gadjett/collections.cljc","^Q",18,"^X",["^S",[["^1?","^20","^21"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",444,"^P",444,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["^1?","^20","^21"]]]]],"^U","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"~$edn-zip",["^ ","^K",null,"^L",["^ ","^M","^;","^N",625,"^O",7,"^P",625,"^Q",14,"^R",["^S",["^T",["^S",[["~$root"]]]]],"^U","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^:","~$gadjett.collections/edn-zip","^W",false,"^M","gadjett/collections.cljc","^Q",14,"^X",["^S",[["^24"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",625,"^P",625,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["^24"]]]]],"^U","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$fix-blank-lines",["^ ","^K",null,"^L",["^ ","^M","^;","^N",691,"^O",7,"^P",691,"^Q",22,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"^:","~$gadjett.collections/fix-blank-lines","^W",false,"^M","gadjett/collections.cljc","^Q",22,"^X",["^S",[["~$s"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",691,"^P",691,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"~$map-to-object",["^ ","^K",null,"^L",["^ ","^M","^;","^N",307,"^O",7,"^P",307,"^Q",20,"^R",["^S",["^T",["^S",[["~$f","~$lst"]]]]],"^U","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"^:","~$gadjett.collections/map-to-object","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["~$f","^29"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",307,"^P",307,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$f","^29"]]]]],"^U","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"~$deep-merge",["^ ","^K",null,"^L",["^ ","^M","^;","^N",524,"^O",7,"^P",524,"^Q",17,"^R",["^S",["^T",["^S",[["~$&","~$maps"]]]]],"^U"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n","^1O",["^ ","^W",true,"^[",0,"^X",[["^S",["^2<"]]],"^R",["^S",[["~$&","^2<"]]],"^Z",["^S",[null]]]],"^:","~$gadjett.collections/deep-merge","^W",true,"^M","gadjett/collections.cljc","^Q",17,"^1O",["^ ","^W",true,"^[",0,"^X",[["^S",["^2<"]]],"^R",["^S",[["~$&","^2<"]]],"^Z",["^S",[null]]],"^X",[["^S",["^2<"]]],"^Y",null,"^Z",["^S",[null]],"^O",1,"^N",524,"^P",524,"^[",0,"^10",true,"^R",["^S",[["~$&","^2<"]]],"^U"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n"],"~$mean",["^ ","^K",null,"^L",["^ ","^M","^;","^N",124,"^O",7,"^P",124,"^Q",11,"^R",["^S",["^T",["^S",[["~$x"]]]]],"^U","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"^:","~$gadjett.collections/mean","^W",false,"^M","gadjett/collections.cljc","^Q",11,"^X",["^S",[["~$x"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",124,"^P",124,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$x"]]]]],"^U","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"~$loc-my-replace",["^ ","^K",null,"^L",["^ ","^M","^;","^N",650,"^O",8,"^P",650,"^Q",22,"~:private",true,"^R",["^S",["^T",["^S",[["~$smap","~$loc"]]]]]],"^2A",true,"^:","~$gadjett.collections/loc-my-replace","^W",false,"^M","gadjett/collections.cljc","^Q",22,"^X",["^S",[["^2B","^2C"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",650,"^P",650,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^2B","^2C"]]]]]],"~$map-object-kv",["^ ","^K",null,"^L",["^ ","^M","^;","^N",100,"^O",7,"^P",100,"^Q",20,"^R",["^S",["^T",["^S",[["~$fk","~$fv","~$m"]]]]],"^U","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"^:","~$gadjett.collections/map-object-kv","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["^2F","^2G","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",100,"^P",100,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["^2F","^2G","~$m"]]]]],"^U","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"~$compactize-map-recursive",["^ ","^K",null,"^L",["^ ","^M","^;","^N",251,"^O",7,"^P",251,"^Q",31,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"^:","~$gadjett.collections/compactize-map-recursive","^W",false,"^M","gadjett/collections.cljc","^Q",31,"^X",["^S",[["~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",251,"^P",251,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"~$flatten-keys",["^ ","^K",null,"^L",["^ ","^M","^;","^N",474,"^O",7,"^P",474,"^Q",19,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"^:","~$gadjett.collections/flatten-keys","^W",false,"^M","gadjett/collections.cljc","^Q",19,"^X",["^S",[["~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",474,"^P",474,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"~$scale",["^ ","^K",null,"^L",["^ ","^M","^;","^N",21,"^O",8,"^P",21,"^Q",13,"^2A",true,"^R",["^S",["^T",["^S",[["~$x","~$y"]]]]]],"^2A",true,"^:","~$gadjett.collections/scale","^W",false,"^M","gadjett/collections.cljc","^Q",13,"^X",["^S",[["~$x","~$y"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",21,"^P",21,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$x","~$y"]]]]]],"~$flatten-keys*",["^ ","^K",null,"^L",["^ ","^M","^;","^N",467,"^O",8,"^P",467,"^Q",21,"^2A",true,"^R",["^S",["^T",["^S",[["~$a","^19","~$m"]]]]]],"^2A",true,"^:","~$gadjett.collections/flatten-keys*","^W",false,"^M","gadjett/collections.cljc","^Q",21,"^X",["^S",[["~$a","^19","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",467,"^P",467,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["~$a","^19","~$m"]]]]]],"~$almost=",["^ ","^K",null,"^L",["^ ","^M","^;","^N",26,"^O",7,"^P",26,"^Q",14,"^R",["^S",["^T",["^S",[["~$x","~$y"],["~$x","~$y","~$epsilon"]]]]],"^1O",["^ ","^W",false,"^[",3,"^X",["^S",[["~$x","~$y"],["~$x","~$y","^2R"]]],"^R",["^S",[["~$x","~$y"],["~$x","~$y","^2R"]]],"^Z",["^S",[null,null]]]],"^:","~$gadjett.collections/almost=","^W",false,"^M","gadjett/collections.cljc","^Q",14,"^1O",["^ ","^W",false,"^[",3,"^X",["^S",[["~$x","~$y"],["~$x","~$y","^2R"]]],"^R",["^S",[["~$x","~$y"],["~$x","~$y","^2R"]]],"^Z",["^S",[null,null]]],"^X",["^S",[["~$x","~$y"],["~$x","~$y","^2R"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",26,"^P",26,"^[",3,"^10",true,"^R",["^S",[["~$x","~$y"],["~$x","~$y","^2R"]]]],"~$compactize-map",["^ ","^K",null,"^L",["^ ","^M","^;","^N",239,"^O",7,"^P",239,"^Q",21,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"^:","~$gadjett.collections/compactize-map","^W",false,"^M","gadjett/collections.cljc","^Q",21,"^X",["^S",[["~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",239,"^P",239,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"~$partition-between",["^ ","^K",null,"^L",["^ ","^M","^;","^N",595,"^O",7,"^P",595,"^Q",24,"^R",["^S",["^T",["^S",[["^1@","^1?"]]]]],"^U","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"^:","~$gadjett.collections/partition-between","^W",false,"^M","gadjett/collections.cljc","^Q",24,"^X",["^S",[["^1@","^1?"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",595,"^P",595,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^1@","^1?"]]]]],"^U","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"~$take-from-map",["^ ","^K",null,"^L",["^ ","^M","^;","^N",496,"^O",7,"^P",496,"^Q",20,"^R",["^S",["^T",["^S",[["~$n","~$m"]]]]],"^U","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^:","~$gadjett.collections/take-from-map","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["~$n","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",496,"^P",496,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$n","~$m"]]]]],"^U","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$map-nested-vals",["^ ","^K",null,"^L",["^ ","^M","^;","^N",760,"^O",7,"^P",760,"^Q",22,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"^:","~$gadjett.collections/map-nested-vals","^W",false,"^M","gadjett/collections.cljc","^Q",22,"^X",["^S",[["~$f","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",760,"^P",760,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"~$compact",["^ ","^K",null,"^L",["^ ","^M","^;","^N",724,"^O",11,"^P",724,"^Q",18,"^R",["^S",["^T",["^S",[["~$x","~$&",["^ ","^1J",["~$max-elements-in-coll","~$max-chars-in-str"],"^1M",["^ ","^31",10,"^32",20],"^1:","~$args"]]]]]],"^U","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  ","^1O",["^ ","^W",true,"^[",1,"^X",[["^S",["~$x",["^ ","^1J",["^31","^32"],"^1M",["^ ","^31",10,"^32",20],"^1:","^33"]]]],"^R",["^S",[["~$x","~$&",["^ ","^1J",["^31","^32"],"^1M",["^ ","^31",10,"^32",20],"^1:","^33"]]]],"^Z",["^S",[null]]]],"^:","~$gadjett.collections/compact","^W",true,"^M","gadjett/collections.cljc","^Q",18,"^1O",["^ ","^W",true,"^[",1,"^X",[["^S",["~$x",["^ ","^1J",["^31","^32"],"^1M",["^ ","^31",10,"^32",20],"^1:","^33"]]]],"^R",["^S",[["~$x","~$&",["^ ","^1J",["^31","^32"],"^1M",["^ ","^31",10,"^32",20],"^1:","^33"]]]],"^Z",["^S",[null]]],"^X",[["^S",["~$x",["^ ","^1J",["^31","^32"],"^1M",["^ ","^31",10,"^32",20],"^1:","^33"]]]],"^Y",null,"^Z",["^S",[null]],"^O",5,"^N",724,"^P",724,"^[",1,"^10",true,"^R",["^S",[["~$x","~$&",["^ ","^1J",["^31","^32"],"^1M",["^ ","^31",10,"^32",20],"^1:","^33"]]]],"^U","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  "],"~$substr",["^ ","^K",null,"^L",["^ ","^M","^;","^N",790,"^O",7,"^P",790,"^Q",13,"^R",["^S",["^T",["^S",[["~$s","^20"],["~$s","^20","^21"]]]]],"^U","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  ","^1O",["^ ","^W",false,"^[",3,"^X",["^S",[["~$s","^20"],["~$s","^20","^21"]]],"^R",["^S",[["~$s","^20"],["~$s","^20","^21"]]],"^Z",["^S",[null,null]]]],"^:","~$gadjett.collections/substr","^W",false,"^M","gadjett/collections.cljc","^Q",13,"^1O",["^ ","^W",false,"^[",3,"^X",["^S",[["~$s","^20"],["~$s","^20","^21"]]],"^R",["^S",[["~$s","^20"],["~$s","^20","^21"]]],"^Z",["^S",[null,null]]],"^X",["^S",[["~$s","^20"],["~$s","^20","^21"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",790,"^P",790,"^[",3,"^10",true,"^R",["^S",[["~$s","^20"],["~$s","^20","^21"]]],"^U","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  "],"~$map-with-index",["^ ","^K",null,"^L",["^ ","^M","^;","^N",330,"^O",7,"^P",330,"^Q",21,"^R",["^S",["^T",["^S",[["~$s","~$idx-key","~$val-key"]]]]],"^U","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"^:","~$gadjett.collections/map-with-index","^W",false,"^M","gadjett/collections.cljc","^Q",21,"^X",["^S",[["~$s","^38","^39"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",330,"^P",330,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["~$s","^38","^39"]]]]],"^U","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"~$map-object-with-key",["^ ","^K",null,"^L",["^ ","^M","^;","^N",90,"^O",7,"^P",90,"^Q",26,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/map-object-with-key","^W",false,"^M","gadjett/collections.cljc","^Q",26,"^X",["^S",[["~$f","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",90,"^P",90,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"~$deep-merge*",["^ ","^K",null,"^L",["^ ","^M","^;","^N",515,"^O",8,"^P",515,"^Q",19,"^2A",true,"^R",["^S",["^T",["^S",[["~$&","^2<"]]]]],"^1O",["^ ","^W",true,"^[",0,"^X",[["^S",["^2<"]]],"^R",["^S",[["~$&","^2<"]]],"^Z",["^S",[null]]]],"^2A",true,"^:","~$gadjett.collections/deep-merge*","^W",true,"^M","gadjett/collections.cljc","^Q",19,"^1O",["^ ","^W",true,"^[",0,"^X",[["^S",["^2<"]]],"^R",["^S",[["~$&","^2<"]]],"^Z",["^S",[null]]],"^X",[["^S",["^2<"]]],"^Y",null,"^Z",["^S",[null]],"^O",1,"^N",515,"^P",515,"^[",0,"^10",true,"^R",["^S",[["~$&","^2<"]]]],"~$range-till-end",["^ ","^K",null,"^L",["^ ","^M","^;","^N",169,"^O",7,"^P",169,"^Q",21,"^R",["^S",["^T",["^S",[["~$&","^33"]]]]],"^U","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  ","^1O",["^ ","^W",true,"^[",0,"^X",[["^S",["^33"]]],"^R",["^S",[["~$&","^33"]]],"^Z",["^S",[null]]]],"^:","~$gadjett.collections/range-till-end","^W",true,"^M","gadjett/collections.cljc","^Q",21,"^1O",["^ ","^W",true,"^[",0,"^X",[["^S",["^33"]]],"^R",["^S",[["~$&","^33"]]],"^Z",["^S",[null]]],"^X",[["^S",["^33"]]],"^Y",null,"^Z",["^S",[null]],"^O",1,"^N",169,"^P",169,"^[",0,"^10",true,"^R",["^S",[["~$&","^33"]]],"^U","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  "],"~$nearest-of-seq",["^ ","^K",null,"^L",["^ ","^M","^;","^N",294,"^O",7,"^P",294,"^Q",21,"^R",["^S",["^T",["^S",[["~$a","~$b"]]]]],"^U","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"^:","~$gadjett.collections/nearest-of-seq","^W",false,"^M","gadjett/collections.cljc","^Q",21,"^X",["^S",[["~$a","~$b"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",294,"^P",294,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$a","~$b"]]]]],"^U","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"~$range-with-end",["^ ","^K",null,"^L",["^ ","^M","^;","^N",164,"^O",8,"^P",164,"^Q",22,"^2A",true,"^R",["^S",["^T",["^S",[["^21"],["^20","^21"],["^20","^21","~$steps"]]]]],"^1O",["^ ","^W",false,"^[",3,"^X",["^S",[["^21"],["^20","^21"],["^20","^21","^3D"]]],"^R",["^S",[["^21"],["^20","^21"],["^20","^21","^3D"]]],"^Z",["^S",[null,null,null]]]],"^2A",true,"^:","~$gadjett.collections/range-with-end","^W",false,"^M","gadjett/collections.cljc","^Q",22,"^1O",["^ ","^W",false,"^[",3,"^X",["^S",[["^21"],["^20","^21"],["^20","^21","^3D"]]],"^R",["^S",[["^21"],["^20","^21"],["^20","^21","^3D"]]],"^Z",["^S",[null,null,null]]],"^X",["^S",[["^21"],["^20","^21"],["^20","^21","^3D"]]],"^Y",null,"^Z",["^S",[null,null,null]],"^O",1,"^N",164,"^P",164,"^[",3,"^10",true,"^R",["^S",[["^21"],["^20","^21"],["^20","^21","^3D"]]]],"~$branches-and-leaves",["^ ","^K",null,"^L",["^ ","^M","^;","^N",559,"^O",7,"^P",559,"^Q",26,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"^:","~$gadjett.collections/branches-and-leaves","^W",false,"^M","gadjett/collections.cljc","^Q",26,"^X",["^S",[["~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",559,"^P",559,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"~$deep-merge-with",["^ ","^K",null,"^L",["^ ","^M","^;","^N",545,"^O",7,"^P",545,"^Q",22,"^R",["^S",["^T",["^S",[["~$g","~$&","^2<"]]]]],"^U","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n","^1O",["^ ","^W",true,"^[",1,"^X",[["^S",["~$g","^2<"]]],"^R",["^S",[["~$g","~$&","^2<"]]],"^Z",["^S",[null]]]],"^:","~$gadjett.collections/deep-merge-with","^W",true,"^M","gadjett/collections.cljc","^Q",22,"^1O",["^ ","^W",true,"^[",1,"^X",[["^S",["~$g","^2<"]]],"^R",["^S",[["~$g","~$&","^2<"]]],"^Z",["^S",[null]]],"^X",[["^S",["~$g","^2<"]]],"^Y",null,"^Z",["^S",[null]],"^O",1,"^N",545,"^P",545,"^[",1,"^10",true,"^R",["^S",[["~$g","~$&","^2<"]]],"^U","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n"],"~$remove-blank-lines",["^ ","^K",null,"^L",["^ ","^M","^;","^N",709,"^O",7,"^P",709,"^Q",25,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"^:","~$gadjett.collections/remove-blank-lines","^W",false,"^M","gadjett/collections.cljc","^Q",25,"^X",["^S",[["~$s"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",709,"^P",709,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"~$select-vals",["^ ","^K",null,"^L",["^ ","^M","^;","^N",809,"^O",7,"^P",809,"^Q",18,"^R",["^S",["^T",["^S",[["~$map","~$keyseq"]]]]]],"^:","~$gadjett.collections/select-vals","^W",false,"^M","gadjett/collections.cljc","^Q",18,"^X",["^S",[["^3M","^3N"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",809,"^P",809,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^3M","^3N"]]]]]],"~$sequence-of-maps->map",["^ ","^K",null,"^L",["^ ","^M","^;","^N",146,"^O",7,"^P",146,"^Q",28,"^R",["^S",["^T",["^S",[["^1?","~$key-fn","~$val-fn"]]]]],"^U","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"^:","~$gadjett.collections/sequence-of-maps->map","^W",false,"^M","gadjett/collections.cljc","^Q",28,"^X",["^S",[["^1?","^3Q","^3R"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",146,"^P",146,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["^1?","^3Q","^3R"]]]]],"^U","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"~$filter-branches",["^ ","^K",null,"^L",["^ ","^M","^;","^N",573,"^O",7,"^P",573,"^Q",22,"^R",["^S",["^T",["^S",[["~$m","~$p"]]]]],"^U","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"^:","~$gadjett.collections/filter-branches","^W",false,"^M","gadjett/collections.cljc","^Q",22,"^X",["^S",[["~$m","~$p"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",573,"^P",573,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$m","~$p"]]]]],"^U","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"~$select-keys-in-order",["^ ","^K",null,"^L",["^ ","^M","^;","^N",804,"^O",7,"^P",804,"^Q",27,"^R",["^S",["^T",["^S",[["~$m","^3N"]]]]],"^U","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^:","~$gadjett.collections/select-keys-in-order","^W",false,"^M","gadjett/collections.cljc","^Q",27,"^X",["^S",[["~$m","^3N"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",804,"^P",804,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$m","^3N"]]]]],"^U","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$comment?",["^ ","^K",null,"^L",["^ ","^M","^;","^N",672,"^O",8,"^P",672,"^Q",16,"^2A",true,"^R",["^S",["^T",["^S",[["~$s"]]]]]],"^2A",true,"^:","~$gadjett.collections/comment?","^W",false,"^M","gadjett/collections.cljc","^Q",16,"^X",["^S",[["~$s"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",672,"^P",672,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$s"]]]]]],"~$out-of-bound?",["^ ","^K",null,"^L",["^ ","^M","^;","^N",585,"^O",7,"^P",585,"^Q",20,"^R",["^S",["^T",["^S",[["~$v","~$idx"]]]]],"^U","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"^:","~$gadjett.collections/out-of-bound?","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["~$v","^3["]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",585,"^P",585,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$v","^3["]]]]],"^U","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"~$map-2d-vec",["^ ","^K",null,"^L",["^ ","^M","^;","^N",57,"^O",7,"^P",57,"^Q",17,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"^:","~$gadjett.collections/map-2d-vec","^W",false,"^M","gadjett/collections.cljc","^Q",17,"^X",["^S",[["~$f","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",57,"^P",57,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"~$split-by-predicate",["^ ","^K",null,"^L",["^ ","^M","^;","^N",380,"^O",7,"^P",380,"^Q",25,"^R",["^S",["^T",["^S",[["^1?","^1@","~$n"]]]]],"^U","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^:","~$gadjett.collections/split-by-predicate","^W",false,"^M","gadjett/collections.cljc","^Q",25,"^X",["^S",[["^1?","^1@","~$n"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",380,"^P",380,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["^1?","^1@","~$n"]]]]],"^U","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"~$abs",["^ ","^K",null,"^L",["^ ","^M","^;","^N",10,"^O",7,"^P",10,"^Q",10,"^R",["^S",["^T",["^S",[["~$x"]]]]],"^U","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"^:","~$gadjett.collections/abs","^W",false,"^M","gadjett/collections.cljc","^Q",10,"^X",["^S",[["~$x"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",10,"^P",10,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$x"]]]]],"^U","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"~$deep-merge-with*",["^ ","^K",null,"^L",["^ ","^M","^;","^N",536,"^O",8,"^P",536,"^Q",24,"^2A",true,"^R",["^S",["^T",["^S",[["~$g","~$&","^2<"]]]]],"^1O",["^ ","^W",true,"^[",1,"^X",[["^S",["~$g","^2<"]]],"^R",["^S",[["~$g","~$&","^2<"]]],"^Z",["^S",[null]]]],"^2A",true,"^:","~$gadjett.collections/deep-merge-with*","^W",true,"^M","gadjett/collections.cljc","^Q",24,"^1O",["^ ","^W",true,"^[",1,"^X",[["^S",["~$g","^2<"]]],"^R",["^S",[["~$g","~$&","^2<"]]],"^Z",["^S",[null]]],"^X",[["^S",["~$g","^2<"]]],"^Y",null,"^Z",["^S",[null]],"^O",1,"^N",536,"^P",536,"^[",1,"^10",true,"^R",["^S",[["~$g","~$&","^2<"]]]],"~$join-them",["^ ","^K",null,"^L",["^ ","^M","^;","^N",773,"^O",7,"^P",773,"^Q",16,"^R",["^S",["^T",["^S",[["~$fns","~$colls"]]]]],"^U","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"^:","~$gadjett.collections/join-them","^W",false,"^M","gadjett/collections.cljc","^Q",16,"^X",["^S",[["^4:","^4;"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",773,"^P",773,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^4:","^4;"]]]]],"^U","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"~$append-cyclic",["^ ","^K",null,"^L",["^ ","^M","^;","^N",189,"^O",7,"^P",189,"^Q",20,"^R",["^S",["^T",["^S",[["^29","~$a"]]]]],"^U","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"^:","~$gadjett.collections/append-cyclic","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["^29","~$a"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",189,"^P",189,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^29","~$a"]]]]],"^U","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"~$select-vals-in-order",["^ ","^K",null,"^L",["^ ","^M","^;","^N",812,"^O",7,"^P",812,"^Q",27,"^R",["^S",["^T",["^S",[["^3M","^19"]]]]],"^U","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^:","~$gadjett.collections/select-vals-in-order","^W",false,"^M","gadjett/collections.cljc","^Q",27,"^X",["^S",[["^3M","^19"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",812,"^P",812,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^3M","^19"]]]]],"^U","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$collify",["^ ","^K",null,"^L",["^ ","^M","^;","^N",611,"^O",7,"^P",611,"^Q",14,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"^:","~$gadjett.collections/collify","^W",false,"^M","gadjett/collections.cljc","^Q",14,"^X",["^S",[["~$s"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",611,"^P",611,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"~$map-2d-vec-kv",["^ ","^K",null,"^L",["^ ","^M","^;","^N",68,"^O",7,"^P",68,"^Q",20,"^R",["^S",["^T",["^S",[["^2F","^2G","~$m"]]]]],"^U","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"^:","~$gadjett.collections/map-2d-vec-kv","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["^2F","^2G","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",68,"^P",68,"^[",3,"^10",true,"^R",["^S",["^T",["^S",[["^2F","^2G","~$m"]]]]],"^U","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"~$max-and-min",["^ ","^K",null,"^L",["^ ","^M","^;","^N",227,"^O",7,"^P",227,"^Q",18,"^R",["^S",["^T",["^S",[["~$x"]]]]],"^U","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"^:","~$gadjett.collections/max-and-min","^W",false,"^M","gadjett/collections.cljc","^Q",18,"^X",["^S",[["~$x"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",227,"^P",227,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$x"]]]]],"^U","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"~$index-of",["^ ","^K",null,"^L",["^ ","^M","^;","^N",456,"^O",7,"^P",456,"^Q",15,"^R",["^S",["^T",["^S",[["~$s","~$element"]]]]],"^U","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"^:","~$gadjett.collections/index-of","^W",false,"^M","gadjett/collections.cljc","^Q",15,"^X",["^S",[["~$s","^4H"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",456,"^P",456,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$s","^4H"]]]]],"^U","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"~$nearest-of-ss",["^ ","^K",null,"^L",["^ ","^M","^;","^N",282,"^O",7,"^P",282,"^Q",20,"^R",["^S",["^T",["^S",[["~$ss","~$x"]]]]],"^U","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"^:","~$gadjett.collections/nearest-of-ss","^W",false,"^M","gadjett/collections.cljc","^Q",20,"^X",["^S",[["^4K","~$x"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",282,"^P",282,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^4K","~$x"]]]]],"^U","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"~$map-reverse-hierarchy",["^ ","^K",null,"^L",["^ ","^M","^;","^N",110,"^O",7,"^P",110,"^Q",28,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"^:","~$gadjett.collections/map-reverse-hierarchy","^W",false,"^M","gadjett/collections.cljc","^Q",28,"^X",["^S",[["~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",110,"^P",110,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$m"]]]]],"^U","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"~$remove-ending-comments",["^ ","^K",null,"^L",["^ ","^M","^;","^N",675,"^O",7,"^P",675,"^Q",29,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"^:","~$gadjett.collections/remove-ending-comments","^W",false,"^M","gadjett/collections.cljc","^Q",29,"^X",["^S",[["~$s"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",675,"^P",675,"^[",1,"^10",true,"^R",["^S",["^T",["^S",[["~$s"]]]]],"^U","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"~$map-object",["^ ","^K",null,"^L",["^ ","^M","^;","^N",80,"^O",7,"^P",80,"^Q",17,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/map-object","^W",false,"^M","gadjett/collections.cljc","^Q",17,"^X",["^S",[["~$f","~$m"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",80,"^P",80,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$f","~$m"]]]]],"^U","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"~$=set",["^ ","^K",null,"^L",["^ ","^M","^;","^N",33,"^O",8,"^P",33,"^Q",12,"^2A",true,"^R",["^S",["^T",["^S",[["~$a","~$b"]]]]]],"^2A",true,"^:","~$gadjett.collections/=set","^W",false,"^M","gadjett/collections.cljc","^Q",12,"^X",["^S",[["~$a","~$b"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",33,"^P",33,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["~$a","~$b"]]]]]],"~$my-replace",["^ ","^K",null,"^L",["^ ","^M","^;","^N",657,"^O",7,"^P",657,"^Q",17,"^R",["^S",["^T",["^S",[["^2B","~$form"]]]]],"^U","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "],"^:","~$gadjett.collections/my-replace","^W",false,"^M","gadjett/collections.cljc","^Q",17,"^X",["^S",[["^2B","^4V"]]],"^Y",null,"^Z",["^S",[null,null]],"^O",1,"^N",657,"^P",657,"^[",2,"^10",true,"^R",["^S",["^T",["^S",[["^2B","^4V"]]]]],"^U","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["^4V","^3[","~$&","~$x","^2?","^J","^11","^21","^13","^2D","^18","^1>","^3K","^4R","^2F","^2N","^2C","^1B","^3S","~:max-elements-in-coll","^3U","^3M","^1D","^2W","^2Y","~$p","^;","^42","^25","~$a","^1E","^1H","^36","^1Q","^3:","^2A","~:else","^48","^4<","^3>","^4;","^1S","^3@","~$y","^33","^1V","^3B","^3E","^4B","^1N","^4D","^4F","~:max-chars-in-str","~:ns","^1[","^:","^1:","^23","^W","^4:","^1M","~:first-val","^29","^M","~$v","^4L","^4P","^4N","^4T","^3O","^31","^Q","^1O","^4W","~:branches","^4H","^26","^28","^2;","^39","^2>","^1T","^1@","^40","^X","^19","^2@","^2E","^34","^2I","^46","^2K","^2M","^Z","^3<","^32","^2O","^2Q","^O","^2T","^16","^14","^1G","^2V","^2X","~$n","^2Z","~$m","^3D","^4I","^1L","^30","^35","^37","^1R","^1J","~:leaves","^20","^1?","^3;","^3=","^N","^3?","^3A","^3C","^3W","^3Y","~:max-val","^3N","^12","^3F","^17","~$s","^1<","^38","^3H","^44","^3J","~$k","^1A","^3L","^1C","^4>","^P","^3P","^3T","^4@","^3V","^27","^2:","^3X","^2=","^3Q","~$g","^3G","^1;","^3Z","^2<","^[","^2B","^41","^1P","^2H","^3I","^43","^2J","^3R","^45","^24","^47","^2L","^49","^R","^4=","^1K","^2P","^1U","^2S","^4?","^1W","^2U","^U","^2G","^15","^4A","^1X","^4C","^2[","^4E","^V","^22","^2R","^1F","^4K","~$b","~:test","^4G","^1I","^4J","^4M","^4O","^4Q","^4S","~$d","~$f","^4U"]],"~:order",["^1X","^52","^:","^M","^Q","^O","^N","^P","^R","^U","^57","^;","^1N","^46","^45","~$x","^2N","^2A","^2M","~$y","^2S","^1O","^2Q","^W","^[","^X","^Z","^2R","^4T","^4S","~$a","~$b","^17","^13","^14","^15","^16","^1U","^1S","^1T","^42","^41","~$f","~$m","^4D","^4C","^2F","^2G","^4R","^4Q","^3<","^3;","^2H","^2E","^4N","^4M","^2?","^2>","^12","^11","~$s","^3S","^3P","^1?","^3Q","^3R","^3E","^3C","^21","^20","^3D","^3@","^3?","^33","~$&","^4>","^4=","^29","^1W","^1V","~$k","~$v","~$n","^4F","^4E","^2U","^2T","^2J","^2I","^1R","^1Q","^4L","^4J","^4K","^3B","^3A","^2:","^28","^1C","^1B","^3:","^37","^38","^39","^1<","^18","^19","^1:","^1;","^1P","^1H","^1I","^1J","^1M","^1K","^1L","^56","^53","^44","^43","^1@","^1A","^1>","~$d","^1G","^1D","^1E","^1F","^22","^1[","^4I","^4G","^4H","^2P","^2O","^2L","^2K","^V","^J","^2Y","^2X","^3>","^3=","^2<","^2=","^2;","^48","^47","~$g","^3I","^3H","^54","^55","^3G","^3F","^3U","^3T","~$p","^40","^3Z","^3[","^2W","^2V","^4B","^4A","^25","^23","^24","^2D","^2@","^2B","^2C","^4W","^4U","^4V","^3Y","^3X","^4P","^4O","^27","^26","^3K","^3J","^34","^30","^31","^32","^4[","^51","^50","^2[","^2Z","^4<","^49","^4:","^4;","^36","^35","^3W","^3V","^3N","^3O","^3L","^3M","^4@","^4?"]],"^U",null]