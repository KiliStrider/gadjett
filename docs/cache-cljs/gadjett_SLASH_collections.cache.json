["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "],"~$Infinity",["^ "],"~$Function",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$gadjett.collections","~:imports",null,"~:requires",["^ ","~$clojure.set","^>","~$clojure.string","^?","~$zip","~$clojure.zip","^A","^A"],"~:uses",["^ ","~$union","^>","~$join","^?","~$split-lines","^?","~$blank?","^?"],"~:defs",["^ ","~$unflatten-keys",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^;","~:line",466,"~:column",7,"~:end-line",466,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^Q",[["~$m"]]]]],"~:doc","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"^:","~$gadjett.collections/unflatten-keys","~:variadic",false,"^K","gadjett/collections.cljc","^O",21,"~:method-params",["^Q",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^Q",[null,null]],"^M",1,"^L",466,"^N",466,"~:max-fixed-arity",1,"~:fn-var",true,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"~$sequence->map",["^ ","^I",null,"^J",["^ ","^K","^;","^L",135,"^M",7,"^N",135,"^O",20,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"^:","~$gadjett.collections/sequence->map","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["~$s"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",135,"^N",135,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"~$=without-keys?",["^ ","^I",null,"^J",["^ ","^K","^;","^L",36,"^M",7,"^N",36,"^O",21,"^P",["^Q",["^R",["^Q",[["~$obj-a","~$obj-b","~$keys-list"]]]]],"^S","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"^:","~$gadjett.collections/=without-keys?","^U",false,"^K","gadjett/collections.cljc","^O",21,"^V",["^Q",[["^12","^13","^14"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",36,"^N",36,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["^12","^13","^14"]]]]],"^S","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"~$dissoc-in",["^ ","^I",null,"^J",["^ ","^K","^;","^L",321,"^M",7,"^N",321,"^O",16,"^P",["^Q",["^R",["^Q",[["~$m",["~$k","~$&","~$ks","~:as","~$keys"]]]]]],"^S","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"^:","~$gadjett.collections/dissoc-in","^U",false,"^K","gadjett/collections.cljc","^O",16,"^V",["^Q",[["~$m","~$p__220"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",321,"^N",321,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$m",["~$k","~$&","^17","^18","^19"]]]]]],"^S","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"~$split-by-predicate-positions",["^ ","^I",null,"^J",["^ ","^K","^;","^L",377,"^M",7,"^N",377,"^O",35,"^P",["^Q",["^R",["^Q",[["~$coll","~$pred","~$n","~$d"]]]]],"^S","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"^:","~$gadjett.collections/split-by-predicate-positions","^U",false,"^K","gadjett/collections.cljc","^O",35,"^V",["^Q",[["^1=","^1>","~$n","~$d"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",377,"^N",377,"^Y",4,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1=","^1>","~$n","~$d"]]]]],"^S","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"~$mapify",["^ ","^I",null,"^J",["^ ","^K","^;","^L",298,"^M",7,"^N",298,"^O",13,"^P",["^Q",["^R",["^Q",[["~$f","~$s"]]]]],"^S","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"^:","~$gadjett.collections/mapify","^U",false,"^K","gadjett/collections.cljc","^O",13,"^V",["^Q",[["~$f","~$s"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",298,"^N",298,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$f","~$s"]]]]],"^S","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"~$submap?",["^ ","^I",null,"^J",["^ ","^K","^;","^L",410,"^M",7,"^N",410,"^O",14,"^P",["^Q",["^R",["^Q",[["~$m1","~$m2"]]]]],"^S","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"^:","~$gadjett.collections/submap?","^U",false,"^K","gadjett/collections.cljc","^O",14,"^V",["^Q",[["^1C","^1D"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",410,"^N",410,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1C","^1D"]]]]],"^S","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"~$positions",["^ ","^I",null,"^J",["^ ","^K","^;","^L",346,"^M",7,"^N",346,"^O",16,"^P",["^Q",["^R",["^Q",[["~$coll-of-lengths","~$&",["^ ","~:keys",["~$max-val","~$first-val"],"~:or",["^ ","^1I","~$infinity","^1J",0]]]]]]],"^S","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  ","~:top-fn",["^ ","^U",true,"^Y",1,"^V",[["^Q",["^1G",["^ ","^1H",["^1I","^1J"],"^1K",["^ ","^1I","^1L","^1J",0]]]]],"^P",["^Q",[["^1G","~$&",["^ ","^1H",["^1I","^1J"],"^1K",["^ ","^1I","^1L","^1J",0]]]]],"^X",["^Q",[null]]]],"^:","~$gadjett.collections/positions","^U",true,"^K","gadjett/collections.cljc","^O",16,"^1M",["^ ","^U",true,"^Y",1,"^V",[["^Q",["^1G",["^ ","^1H",["^1I","^1J"],"^1K",["^ ","^1I","^1L","^1J",0]]]]],"^P",["^Q",[["^1G","~$&",["^ ","^1H",["^1I","^1J"],"^1K",["^ ","^1I","^1L","^1J",0]]]]],"^X",["^Q",[null]]],"^V",[["^Q",["^1G",["^ ","^1H",["^1I","^1J"],"^1K",["^ ","^1I","^1L","^1J",0]]]]],"^W",null,"^X",["^Q",[null]],"^M",1,"^L",346,"^N",346,"^Y",1,"^Z",true,"^P",["^Q",[["^1G","~$&",["^ ","^1H",["^1I","^1J"],"^1K",["^ ","^1I","^1L","^1J",0]]]]],"^S","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  "],"~$filter-map",["^ ","^I",null,"^J",["^ ","^K","^;","^L",248,"^M",7,"^N",248,"^O",17,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/filter-map","^U",false,"^K","gadjett/collections.cljc","^O",17,"^V",["^Q",[["~$f","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",248,"^N",248,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"~$vec->map",["^ ","^I",null,"^J",["^ ","^K","^;","^L",46,"^M",7,"^N",46,"^O",15,"^P",["^Q",["^R",["^Q",[["~$vec"]]]]],"^S","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"^:","~$gadjett.collections/vec->map","^U",false,"^K","gadjett/collections.cljc","^O",15,"^V",["^Q",[["^1R"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",46,"^N",46,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1R"]]]]],"^S","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"~$assoc-cyclic",["^ ","^I",null,"^J",["^ ","^K","^;","^L",204,"^M",7,"^N",204,"^O",19,"^P",["^Q",["^R",["^Q",[["^1=","~$k","~$v"],["^1=","~$k","~$v","~$n"]]]]],"^S","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  ","^1M",["^ ","^U",false,"^Y",4,"^V",["^Q",[["^1=","~$k","~$v"],["^1=","~$k","~$v","~$n"]]],"^P",["^Q",[["^1=","~$k","~$v"],["^1=","~$k","~$v","~$n"]]],"^X",["^Q",[null,null]]]],"^:","~$gadjett.collections/assoc-cyclic","^U",false,"^K","gadjett/collections.cljc","^O",19,"^1M",["^ ","^U",false,"^Y",4,"^V",["^Q",[["^1=","~$k","~$v"],["^1=","~$k","~$v","~$n"]]],"^P",["^Q",[["^1=","~$k","~$v"],["^1=","~$k","~$v","~$n"]]],"^X",["^Q",[null,null]]],"^V",["^Q",[["^1=","~$k","~$v"],["^1=","~$k","~$v","~$n"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",204,"^N",204,"^Y",4,"^Z",true,"^P",["^Q",[["^1=","~$k","~$v"],["^1=","~$k","~$v","~$n"]]],"^S","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  "],"^1L",["^ ","^:","~$gadjett.collections/infinity","^K","gadjett/collections.cljc","^L",6,"^M",1,"^N",6,"^O",14,"^J",["^ ","^K","^;","^L",6,"^M",6,"^N",6,"^O",14],"~:tag","~$js"],"~$subsequence",["^ ","^I",null,"^J",["^ ","^K","^;","^L",425,"^M",7,"^N",425,"^O",18,"^P",["^Q",["^R",["^Q",[["^1=","~$start","~$end"]]]]],"^S","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"^:","~$gadjett.collections/subsequence","^U",false,"^K","gadjett/collections.cljc","^O",18,"^V",["^Q",[["^1=","^1Z","^1["]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",425,"^N",425,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1=","^1Z","^1["]]]]],"^S","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"~$edn-zip",["^ ","^I",null,"^J",["^ ","^K","^;","^L",606,"^M",7,"^N",606,"^O",14,"^P",["^Q",["^R",["^Q",[["~$root"]]]]],"^S","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^:","~$gadjett.collections/edn-zip","^U",false,"^K","gadjett/collections.cljc","^O",14,"^V",["^Q",[["^22"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",606,"^N",606,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["^22"]]]]],"^S","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$fix-blank-lines",["^ ","^I",null,"^J",["^ ","^K","^;","^L",672,"^M",7,"^N",672,"^O",22,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"^:","~$gadjett.collections/fix-blank-lines","^U",false,"^K","gadjett/collections.cljc","^O",22,"^V",["^Q",[["~$s"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",672,"^N",672,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"~$map-to-object",["^ ","^I",null,"^J",["^ ","^K","^;","^L",288,"^M",7,"^N",288,"^O",20,"^P",["^Q",["^R",["^Q",[["~$f","~$lst"]]]]],"^S","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"^:","~$gadjett.collections/map-to-object","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["~$f","^27"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",288,"^N",288,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$f","^27"]]]]],"^S","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"~$deep-merge",["^ ","^I",null,"^J",["^ ","^K","^;","^L",505,"^M",7,"^N",505,"^O",17,"^P",["^Q",["^R",["^Q",[["~$&","~$maps"]]]]],"^S"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n","^1M",["^ ","^U",true,"^Y",0,"^V",[["^Q",["^2:"]]],"^P",["^Q",[["~$&","^2:"]]],"^X",["^Q",[null]]]],"^:","~$gadjett.collections/deep-merge","^U",true,"^K","gadjett/collections.cljc","^O",17,"^1M",["^ ","^U",true,"^Y",0,"^V",[["^Q",["^2:"]]],"^P",["^Q",[["~$&","^2:"]]],"^X",["^Q",[null]]],"^V",[["^Q",["^2:"]]],"^W",null,"^X",["^Q",[null]],"^M",1,"^L",505,"^N",505,"^Y",0,"^Z",true,"^P",["^Q",[["~$&","^2:"]]],"^S"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n"],"~$mean",["^ ","^I",null,"^J",["^ ","^K","^;","^L",123,"^M",7,"^N",123,"^O",11,"^P",["^Q",["^R",["^Q",[["~$x"]]]]],"^S","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"^:","~$gadjett.collections/mean","^U",false,"^K","gadjett/collections.cljc","^O",11,"^V",["^Q",[["~$x"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",123,"^N",123,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$x"]]]]],"^S","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"~$loc-my-replace",["^ ","^I",null,"^J",["^ ","^K","^;","^L",631,"^M",8,"^N",631,"^O",22,"~:private",true,"^P",["^Q",["^R",["^Q",[["~$smap","~$loc"]]]]]],"^2?",true,"^:","~$gadjett.collections/loc-my-replace","^U",false,"^K","gadjett/collections.cljc","^O",22,"^V",["^Q",[["^2@","^2A"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",631,"^N",631,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^2@","^2A"]]]]]],"~$map-object-kv",["^ ","^I",null,"^J",["^ ","^K","^;","^L",99,"^M",7,"^N",99,"^O",20,"^P",["^Q",["^R",["^Q",[["~$fk","~$fv","~$m"]]]]],"^S","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"^:","~$gadjett.collections/map-object-kv","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["^2D","^2E","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",99,"^N",99,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["^2D","^2E","~$m"]]]]],"^S","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"~$flatten-keys",["^ ","^I",null,"^J",["^ ","^K","^;","^L",455,"^M",7,"^N",455,"^O",19,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"^:","~$gadjett.collections/flatten-keys","^U",false,"^K","gadjett/collections.cljc","^O",19,"^V",["^Q",[["~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",455,"^N",455,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"~$scale",["^ ","^I",null,"^J",["^ ","^K","^;","^L",20,"^M",8,"^N",20,"^O",13,"^2?",true,"^P",["^Q",["^R",["^Q",[["~$x","~$y"]]]]]],"^2?",true,"^:","~$gadjett.collections/scale","^U",false,"^K","gadjett/collections.cljc","^O",13,"^V",["^Q",[["~$x","~$y"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",20,"^N",20,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$x","~$y"]]]]]],"~$flatten-keys*",["^ ","^I",null,"^J",["^ ","^K","^;","^L",448,"^M",8,"^N",448,"^O",21,"^2?",true,"^P",["^Q",["^R",["^Q",[["~$a","^17","~$m"]]]]]],"^2?",true,"^:","~$gadjett.collections/flatten-keys*","^U",false,"^K","gadjett/collections.cljc","^O",21,"^V",["^Q",[["~$a","^17","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",448,"^N",448,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$a","^17","~$m"]]]]]],"~$almost=",["^ ","^I",null,"^J",["^ ","^K","^;","^L",25,"^M",7,"^N",25,"^O",14,"^P",["^Q",["^R",["^Q",[["~$x","~$y"],["~$x","~$y","~$epsilon"]]]]],"^1M",["^ ","^U",false,"^Y",3,"^V",["^Q",[["~$x","~$y"],["~$x","~$y","^2N"]]],"^P",["^Q",[["~$x","~$y"],["~$x","~$y","^2N"]]],"^X",["^Q",[null,null]]]],"^:","~$gadjett.collections/almost=","^U",false,"^K","gadjett/collections.cljc","^O",14,"^1M",["^ ","^U",false,"^Y",3,"^V",["^Q",[["~$x","~$y"],["~$x","~$y","^2N"]]],"^P",["^Q",[["~$x","~$y"],["~$x","~$y","^2N"]]],"^X",["^Q",[null,null]]],"^V",["^Q",[["~$x","~$y"],["~$x","~$y","^2N"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",25,"^N",25,"^Y",3,"^Z",true,"^P",["^Q",[["~$x","~$y"],["~$x","~$y","^2N"]]]],"~$compactize-map",["^ ","^I",null,"^J",["^ ","^K","^;","^L",238,"^M",7,"^N",238,"^O",21,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"^:","~$gadjett.collections/compactize-map","^U",false,"^K","gadjett/collections.cljc","^O",21,"^V",["^Q",[["~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",238,"^N",238,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"~$partition-between",["^ ","^I",null,"^J",["^ ","^K","^;","^L",576,"^M",7,"^N",576,"^O",24,"^P",["^Q",["^R",["^Q",[["^1>","^1="]]]]],"^S","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"^:","~$gadjett.collections/partition-between","^U",false,"^K","gadjett/collections.cljc","^O",24,"^V",["^Q",[["^1>","^1="]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",576,"^N",576,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1>","^1="]]]]],"^S","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"~$take-from-map",["^ ","^I",null,"^J",["^ ","^K","^;","^L",477,"^M",7,"^N",477,"^O",20,"^P",["^Q",["^R",["^Q",[["~$n","~$m"]]]]],"^S","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^:","~$gadjett.collections/take-from-map","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["~$n","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",477,"^N",477,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$n","~$m"]]]]],"^S","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$map-nested-vals",["^ ","^I",null,"^J",["^ ","^K","^;","^L",741,"^M",7,"^N",741,"^O",22,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"^:","~$gadjett.collections/map-nested-vals","^U",false,"^K","gadjett/collections.cljc","^O",22,"^V",["^Q",[["~$f","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",741,"^N",741,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"~$compact",["^ ","^I",null,"^J",["^ ","^K","^;","^L",705,"^M",11,"^N",705,"^O",18,"^P",["^Q",["^R",["^Q",[["~$x","~$&",["^ ","^1H",["~$max-elements-in-coll","~$max-chars-in-str"],"^1K",["^ ","^2Y",10,"^2Z",20],"^18","~$args"]]]]]],"^S","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  ","^1M",["^ ","^U",true,"^Y",1,"^V",[["^Q",["~$x",["^ ","^1H",["^2Y","^2Z"],"^1K",["^ ","^2Y",10,"^2Z",20],"^18","^2["]]]],"^P",["^Q",[["~$x","~$&",["^ ","^1H",["^2Y","^2Z"],"^1K",["^ ","^2Y",10,"^2Z",20],"^18","^2["]]]],"^X",["^Q",[null]]]],"^:","~$gadjett.collections/compact","^U",true,"^K","gadjett/collections.cljc","^O",18,"^1M",["^ ","^U",true,"^Y",1,"^V",[["^Q",["~$x",["^ ","^1H",["^2Y","^2Z"],"^1K",["^ ","^2Y",10,"^2Z",20],"^18","^2["]]]],"^P",["^Q",[["~$x","~$&",["^ ","^1H",["^2Y","^2Z"],"^1K",["^ ","^2Y",10,"^2Z",20],"^18","^2["]]]],"^X",["^Q",[null]]],"^V",[["^Q",["~$x",["^ ","^1H",["^2Y","^2Z"],"^1K",["^ ","^2Y",10,"^2Z",20],"^18","^2["]]]],"^W",null,"^X",["^Q",[null]],"^M",5,"^L",705,"^N",705,"^Y",1,"^Z",true,"^P",["^Q",[["~$x","~$&",["^ ","^1H",["^2Y","^2Z"],"^1K",["^ ","^2Y",10,"^2Z",20],"^18","^2["]]]],"^S","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  "],"~$map-with-index",["^ ","^I",null,"^J",["^ ","^K","^;","^L",311,"^M",7,"^N",311,"^O",21,"^P",["^Q",["^R",["^Q",[["~$s","~$idx-key","~$val-key"]]]]],"^S","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"^:","~$gadjett.collections/map-with-index","^U",false,"^K","gadjett/collections.cljc","^O",21,"^V",["^Q",[["~$s","^32","^33"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",311,"^N",311,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s","^32","^33"]]]]],"^S","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"~$map-object-with-key",["^ ","^I",null,"^J",["^ ","^K","^;","^L",89,"^M",7,"^N",89,"^O",26,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/map-object-with-key","^U",false,"^K","gadjett/collections.cljc","^O",26,"^V",["^Q",[["~$f","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",89,"^N",89,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"~$deep-merge*",["^ ","^I",null,"^J",["^ ","^K","^;","^L",496,"^M",8,"^N",496,"^O",19,"^2?",true,"^P",["^Q",["^R",["^Q",[["~$&","^2:"]]]]],"^1M",["^ ","^U",true,"^Y",0,"^V",[["^Q",["^2:"]]],"^P",["^Q",[["~$&","^2:"]]],"^X",["^Q",[null]]]],"^2?",true,"^:","~$gadjett.collections/deep-merge*","^U",true,"^K","gadjett/collections.cljc","^O",19,"^1M",["^ ","^U",true,"^Y",0,"^V",[["^Q",["^2:"]]],"^P",["^Q",[["~$&","^2:"]]],"^X",["^Q",[null]]],"^V",[["^Q",["^2:"]]],"^W",null,"^X",["^Q",[null]],"^M",1,"^L",496,"^N",496,"^Y",0,"^Z",true,"^P",["^Q",[["~$&","^2:"]]]],"~$range-till-end",["^ ","^I",null,"^J",["^ ","^K","^;","^L",168,"^M",7,"^N",168,"^O",21,"^P",["^Q",["^R",["^Q",[["~$&","^2["]]]]],"^S","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  ","^1M",["^ ","^U",true,"^Y",0,"^V",[["^Q",["^2["]]],"^P",["^Q",[["~$&","^2["]]],"^X",["^Q",[null]]]],"^:","~$gadjett.collections/range-till-end","^U",true,"^K","gadjett/collections.cljc","^O",21,"^1M",["^ ","^U",true,"^Y",0,"^V",[["^Q",["^2["]]],"^P",["^Q",[["~$&","^2["]]],"^X",["^Q",[null]]],"^V",[["^Q",["^2["]]],"^W",null,"^X",["^Q",[null]],"^M",1,"^L",168,"^N",168,"^Y",0,"^Z",true,"^P",["^Q",[["~$&","^2["]]],"^S","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  "],"~$nearest-of-seq",["^ ","^I",null,"^J",["^ ","^K","^;","^L",275,"^M",7,"^N",275,"^O",21,"^P",["^Q",["^R",["^Q",[["~$a","~$b"]]]]],"^S","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"^:","~$gadjett.collections/nearest-of-seq","^U",false,"^K","gadjett/collections.cljc","^O",21,"^V",["^Q",[["~$a","~$b"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",275,"^N",275,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$a","~$b"]]]]],"^S","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"~$range-with-end",["^ ","^I",null,"^J",["^ ","^K","^;","^L",163,"^M",8,"^N",163,"^O",22,"^2?",true,"^P",["^Q",["^R",["^Q",[["^1["],["^1Z","^1["],["^1Z","^1[","~$steps"]]]]],"^1M",["^ ","^U",false,"^Y",3,"^V",["^Q",[["^1["],["^1Z","^1["],["^1Z","^1[","^3>"]]],"^P",["^Q",[["^1["],["^1Z","^1["],["^1Z","^1[","^3>"]]],"^X",["^Q",[null,null,null]]]],"^2?",true,"^:","~$gadjett.collections/range-with-end","^U",false,"^K","gadjett/collections.cljc","^O",22,"^1M",["^ ","^U",false,"^Y",3,"^V",["^Q",[["^1["],["^1Z","^1["],["^1Z","^1[","^3>"]]],"^P",["^Q",[["^1["],["^1Z","^1["],["^1Z","^1[","^3>"]]],"^X",["^Q",[null,null,null]]],"^V",["^Q",[["^1["],["^1Z","^1["],["^1Z","^1[","^3>"]]],"^W",null,"^X",["^Q",[null,null,null]],"^M",1,"^L",163,"^N",163,"^Y",3,"^Z",true,"^P",["^Q",[["^1["],["^1Z","^1["],["^1Z","^1[","^3>"]]]],"~$branches-and-leaves",["^ ","^I",null,"^J",["^ ","^K","^;","^L",540,"^M",7,"^N",540,"^O",26,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"^:","~$gadjett.collections/branches-and-leaves","^U",false,"^K","gadjett/collections.cljc","^O",26,"^V",["^Q",[["~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",540,"^N",540,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"~$deep-merge-with",["^ ","^I",null,"^J",["^ ","^K","^;","^L",526,"^M",7,"^N",526,"^O",22,"^P",["^Q",["^R",["^Q",[["~$g","~$&","^2:"]]]]],"^S","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n","^1M",["^ ","^U",true,"^Y",1,"^V",[["^Q",["~$g","^2:"]]],"^P",["^Q",[["~$g","~$&","^2:"]]],"^X",["^Q",[null]]]],"^:","~$gadjett.collections/deep-merge-with","^U",true,"^K","gadjett/collections.cljc","^O",22,"^1M",["^ ","^U",true,"^Y",1,"^V",[["^Q",["~$g","^2:"]]],"^P",["^Q",[["~$g","~$&","^2:"]]],"^X",["^Q",[null]]],"^V",[["^Q",["~$g","^2:"]]],"^W",null,"^X",["^Q",[null]],"^M",1,"^L",526,"^N",526,"^Y",1,"^Z",true,"^P",["^Q",[["~$g","~$&","^2:"]]],"^S","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n"],"~$remove-blank-lines",["^ ","^I",null,"^J",["^ ","^K","^;","^L",690,"^M",7,"^N",690,"^O",25,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"^:","~$gadjett.collections/remove-blank-lines","^U",false,"^K","gadjett/collections.cljc","^O",25,"^V",["^Q",[["~$s"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",690,"^N",690,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"~$sequence-of-maps->map",["^ ","^I",null,"^J",["^ ","^K","^;","^L",145,"^M",7,"^N",145,"^O",28,"^P",["^Q",["^R",["^Q",[["^1=","~$key-fn","~$val-fn"]]]]],"^S","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"^:","~$gadjett.collections/sequence-of-maps->map","^U",false,"^K","gadjett/collections.cljc","^O",28,"^V",["^Q",[["^1=","^3G","^3H"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",145,"^N",145,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1=","^3G","^3H"]]]]],"^S","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"~$filter-branches",["^ ","^I",null,"^J",["^ ","^K","^;","^L",554,"^M",7,"^N",554,"^O",22,"^P",["^Q",["^R",["^Q",[["~$m","~$p"]]]]],"^S","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"^:","~$gadjett.collections/filter-branches","^U",false,"^K","gadjett/collections.cljc","^O",22,"^V",["^Q",[["~$m","~$p"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",554,"^N",554,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$m","~$p"]]]]],"^S","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"~$comment?",["^ ","^I",null,"^J",["^ ","^K","^;","^L",653,"^M",8,"^N",653,"^O",16,"^2?",true,"^P",["^Q",["^R",["^Q",[["~$s"]]]]]],"^2?",true,"^:","~$gadjett.collections/comment?","^U",false,"^K","gadjett/collections.cljc","^O",16,"^V",["^Q",[["~$s"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",653,"^N",653,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s"]]]]]],"~$out-of-bound?",["^ ","^I",null,"^J",["^ ","^K","^;","^L",566,"^M",7,"^N",566,"^O",20,"^P",["^Q",["^R",["^Q",[["~$v","~$idx"]]]]],"^S","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"^:","~$gadjett.collections/out-of-bound?","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["~$v","^3O"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",566,"^N",566,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$v","^3O"]]]]],"^S","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"~$map-2d-vec",["^ ","^I",null,"^J",["^ ","^K","^;","^L",56,"^M",7,"^N",56,"^O",17,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"^:","~$gadjett.collections/map-2d-vec","^U",false,"^K","gadjett/collections.cljc","^O",17,"^V",["^Q",[["~$f","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",56,"^N",56,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"~$split-by-predicate",["^ ","^I",null,"^J",["^ ","^K","^;","^L",361,"^M",7,"^N",361,"^O",25,"^P",["^Q",["^R",["^Q",[["^1=","^1>","~$n"]]]]],"^S","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^:","~$gadjett.collections/split-by-predicate","^U",false,"^K","gadjett/collections.cljc","^O",25,"^V",["^Q",[["^1=","^1>","~$n"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",361,"^N",361,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["^1=","^1>","~$n"]]]]],"^S","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"~$abs",["^ ","^I",null,"^J",["^ ","^K","^;","^L",9,"^M",7,"^N",9,"^O",10,"^P",["^Q",["^R",["^Q",[["~$x"]]]]],"^S","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"^:","~$gadjett.collections/abs","^U",false,"^K","gadjett/collections.cljc","^O",10,"^V",["^Q",[["~$x"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",9,"^N",9,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$x"]]]]],"^S","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"~$deep-merge-with*",["^ ","^I",null,"^J",["^ ","^K","^;","^L",517,"^M",8,"^N",517,"^O",24,"^2?",true,"^P",["^Q",["^R",["^Q",[["~$g","~$&","^2:"]]]]],"^1M",["^ ","^U",true,"^Y",1,"^V",[["^Q",["~$g","^2:"]]],"^P",["^Q",[["~$g","~$&","^2:"]]],"^X",["^Q",[null]]]],"^2?",true,"^:","~$gadjett.collections/deep-merge-with*","^U",true,"^K","gadjett/collections.cljc","^O",24,"^1M",["^ ","^U",true,"^Y",1,"^V",[["^Q",["~$g","^2:"]]],"^P",["^Q",[["~$g","~$&","^2:"]]],"^X",["^Q",[null]]],"^V",[["^Q",["~$g","^2:"]]],"^W",null,"^X",["^Q",[null]],"^M",1,"^L",517,"^N",517,"^Y",1,"^Z",true,"^P",["^Q",[["~$g","~$&","^2:"]]]],"~$join-them",["^ ","^I",null,"^J",["^ ","^K","^;","^L",754,"^M",7,"^N",754,"^O",16,"^P",["^Q",["^R",["^Q",[["~$fns","~$colls"]]]]],"^S","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"^:","~$gadjett.collections/join-them","^U",false,"^K","gadjett/collections.cljc","^O",16,"^V",["^Q",[["^3Z","^3["]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",754,"^N",754,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^3Z","^3["]]]]],"^S","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"~$append-cyclic",["^ ","^I",null,"^J",["^ ","^K","^;","^L",188,"^M",7,"^N",188,"^O",20,"^P",["^Q",["^R",["^Q",[["^27","~$a"]]]]],"^S","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"^:","~$gadjett.collections/append-cyclic","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["^27","~$a"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",188,"^N",188,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^27","~$a"]]]]],"^S","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"~$collify",["^ ","^I",null,"^J",["^ ","^K","^;","^L",592,"^M",7,"^N",592,"^O",14,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"^:","~$gadjett.collections/collify","^U",false,"^K","gadjett/collections.cljc","^O",14,"^V",["^Q",[["~$s"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",592,"^N",592,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"~$map-2d-vec-kv",["^ ","^I",null,"^J",["^ ","^K","^;","^L",67,"^M",7,"^N",67,"^O",20,"^P",["^Q",["^R",["^Q",[["^2D","^2E","~$m"]]]]],"^S","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"^:","~$gadjett.collections/map-2d-vec-kv","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["^2D","^2E","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",67,"^N",67,"^Y",3,"^Z",true,"^P",["^Q",["^R",["^Q",[["^2D","^2E","~$m"]]]]],"^S","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"~$max-and-min",["^ ","^I",null,"^J",["^ ","^K","^;","^L",226,"^M",7,"^N",226,"^O",18,"^P",["^Q",["^R",["^Q",[["~$x"]]]]],"^S","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"^:","~$gadjett.collections/max-and-min","^U",false,"^K","gadjett/collections.cljc","^O",18,"^V",["^Q",[["~$x"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",226,"^N",226,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$x"]]]]],"^S","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"~$index-of",["^ ","^I",null,"^J",["^ ","^K","^;","^L",437,"^M",7,"^N",437,"^O",15,"^P",["^Q",["^R",["^Q",[["~$s","~$element"]]]]],"^S","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"^:","~$gadjett.collections/index-of","^U",false,"^K","gadjett/collections.cljc","^O",15,"^V",["^Q",[["~$s","^4:"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",437,"^N",437,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s","^4:"]]]]],"^S","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"~$nearest-of-ss",["^ ","^I",null,"^J",["^ ","^K","^;","^L",263,"^M",7,"^N",263,"^O",20,"^P",["^Q",["^R",["^Q",[["~$ss","~$x"]]]]],"^S","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"^:","~$gadjett.collections/nearest-of-ss","^U",false,"^K","gadjett/collections.cljc","^O",20,"^V",["^Q",[["^4=","~$x"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",263,"^N",263,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^4=","~$x"]]]]],"^S","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"~$map-reverse-hierarchy",["^ ","^I",null,"^J",["^ ","^K","^;","^L",109,"^M",7,"^N",109,"^O",28,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"^:","~$gadjett.collections/map-reverse-hierarchy","^U",false,"^K","gadjett/collections.cljc","^O",28,"^V",["^Q",[["~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",109,"^N",109,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$m"]]]]],"^S","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"~$remove-ending-comments",["^ ","^I",null,"^J",["^ ","^K","^;","^L",656,"^M",7,"^N",656,"^O",29,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"^:","~$gadjett.collections/remove-ending-comments","^U",false,"^K","gadjett/collections.cljc","^O",29,"^V",["^Q",[["~$s"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",656,"^N",656,"^Y",1,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$s"]]]]],"^S","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"~$map-object",["^ ","^I",null,"^J",["^ ","^K","^;","^L",79,"^M",7,"^N",79,"^O",17,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/map-object","^U",false,"^K","gadjett/collections.cljc","^O",17,"^V",["^Q",[["~$f","~$m"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",79,"^N",79,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$f","~$m"]]]]],"^S","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"~$=set",["^ ","^I",null,"^J",["^ ","^K","^;","^L",32,"^M",8,"^N",32,"^O",12,"^2?",true,"^P",["^Q",["^R",["^Q",[["~$a","~$b"]]]]]],"^2?",true,"^:","~$gadjett.collections/=set","^U",false,"^K","gadjett/collections.cljc","^O",12,"^V",["^Q",[["~$a","~$b"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",32,"^N",32,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["~$a","~$b"]]]]]],"~$my-replace",["^ ","^I",null,"^J",["^ ","^K","^;","^L",638,"^M",7,"^N",638,"^O",17,"^P",["^Q",["^R",["^Q",[["^2@","~$form"]]]]],"^S","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "],"^:","~$gadjett.collections/my-replace","^U",false,"^K","gadjett/collections.cljc","^O",17,"^V",["^Q",[["^2@","^4H"]]],"^W",null,"^X",["^Q",[null,null]],"^M",1,"^L",638,"^N",638,"^Y",2,"^Z",true,"^P",["^Q",["^R",["^Q",[["^2@","^4H"]]]]],"^S","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["^4H","^3O","~$&","~$x","^2=","^H","^[","^1[","^11","^2B","^16","^1<","^3E","^4D","^2D","^2J","^2A","^1@","^3I","~:max-elements-in-coll","^3K","^1B","^2S","^2U","~$p","^;","^3R","^23","~$a","^1C","^1F","^1O","^34","^2?","~:else","^3X","^40","^38","^3[","^1Q","^3:","~$y","^2[","^1T","^3<","^3?","^44","^1L","^46","^48","~:max-chars-in-str","~:ns","^1Y","^:","^18","^21","^U","^3Z","^1K","~:first-val","^27","^K","~$v","^4>","^4B","^4@","^4F","^2Y","^O","^1M","^4I","~:branches","^4:","^24","^26","^29","^33","^2<","^1R","^1>","^3P","^V","^17","^2>","^2C","^30","^3V","^2G","^2I","^X","^36","^2Z","^2K","^2M","^M","^2P","^14","^12","^1E","^2R","^2T","~$n","^2V","~$m","^3>","^4;","^1J","^2X","^31","^1P","^1H","~:leaves","^1Z","^1=","^35","^37","^L","^39","^3;","^3=","^3M","~:max-val","^10","^3@","^15","~$s","^1:","^32","^3B","^3T","^3D","~$k","^1?","^1A","^42","^N","^3F","^3J","^25","^28","^3L","^2;","^3G","~$g","^3A","^19","^3N","^2:","^Y","^2@","^3Q","^1N","^2F","^3C","^3S","^3H","^3U","^22","^3W","^2H","^3Y","^P","^41","^1I","^2L","^1S","^2O","^1U","^2Q","^S","^2E","^13","^43","^1V","^45","^2W","^47","^T","^20","^2N","^1D","^4=","~$b","~:test","^49","^1G","^4<","^4?","^4A","^4C","^4E","~$d","~$f","^4G"]],"~:order",["^1V","^4P","^:","^K","^O","^M","^L","^N","^P","^S","^4U","^;","^1L","^3V","^3U","~$x","^2J","^2?","^2I","~$y","^2O","^1M","^2M","^U","^Y","^V","^X","^2N","^4F","^4E","~$a","~$b","^15","^11","^12","^13","^14","^1S","^1Q","^1R","^3R","^3Q","~$f","~$m","^46","^45","^2D","^2E","^4D","^4C","^36","^35","^2F","^2C","^4@","^4?","^2=","^2<","^10","^[","~$s","^3I","^3F","^1=","^3G","^3H","^3?","^3=","^1[","^1Z","^3>","^3:","^39","^2[","~$&","^42","^41","^27","^1U","^1T","~$k","~$v","~$n","^48","^47","^2Q","^2P","^1P","^1O","^4>","^4<","^4=","^3<","^3;","^28","^26","^1A","^1@","^34","^31","^32","^33","^1:","^16","^17","^18","^19","^1N","^1F","^1G","^1H","^1K","^1I","^1J","^4T","^4Q","^3T","^3S","^1>","^1?","^1<","~$d","^1E","^1B","^1C","^1D","^20","^1Y","^4;","^49","^4:","^2L","^2K","^2H","^2G","^T","^H","^2U","^2T","^38","^37","^2:","^2;","^29","^3X","^3W","~$g","^3C","^3B","^4R","^4S","^3A","^3@","^3K","^3J","~$p","^3P","^3N","^3O","^2S","^2R","^44","^43","^23","^21","^22","^2B","^2>","^2@","^2A","^4I","^4G","^4H","^3M","^3L","^4B","^4A","^25","^24","^3E","^3D","^30","^2X","^2Y","^2Z","^4M","^4O","^4N","^2W","^2V","^40","^3Y","^3Z","^3["]],"^S",null]