["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ ","~$match","~$cljs.core.match","~$go","~$cljs.core.async.macros","~$go-loop","^9"],"~:excludes",["~#set",[]],"~:name","~$gadjett.async-utils","~:imports",null,"~:requires",["^ ","~$string","~$clojure.string","^B","^B","^7","^7","~$cljs.core.async","^C","~$clojure.core.match","^7","~$clojure.core.async","^C"],"~:uses",["^ ","~$timeout","^C","~$<!","^C","^6","^7","~$alts!","^C"],"~:defs",["^ ","~$safe-memoize-async",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^>","~:line",23,"~:column",7,"~:end-line",23,"~:end-column",25,"~:arglists",["~#list",["~$quote",["^T",[["~$f","~$success-test-fn"]]]]],"~:doc","\n  Usage: `(safe-memoize-async f success-test-fn)`\n\n  Same as memoize-async, but will only memoize the result if it passes the `success-test-fn`.\n  ~~~klipse\n  (def foo (safe-memoize-async (fn [x]\n                               (go\n                                 (println \"running the function with: \" x)\n                                 (if (zero? x)\n                                   [:error]\n                                   [:ok x])))\n                             #(= :ok (first %))))\n\n  (go (println (<! (foo 0)))\n    (println (<! (foo 0)))\n    (println (<! (foo 1)))\n    (println (<! (foo 1))))\n  ~~~\n  "],"^=","~$gadjett.async-utils/safe-memoize-async","~:variadic",false,"^N","gadjett/async_utils.cljc","^R",25,"~:method-params",["^T",[["~$f","^V"]]],"~:protocol-impl",null,"~:arglists-meta",["^T",[null,null]],"^P",1,"^O",23,"^Q",23,"~:max-fixed-arity",2,"~:fn-var",true,"^S",["^T",["^U",["^T",[["~$f","^V"]]]]],"^W","\n  Usage: `(safe-memoize-async f success-test-fn)`\n\n  Same as memoize-async, but will only memoize the result if it passes the `success-test-fn`.\n  ~~~klipse\n  (def foo (safe-memoize-async (fn [x]\n                               (go\n                                 (println \"running the function with: \" x)\n                                 (if (zero? x)\n                                   [:error]\n                                   [:ok x])))\n                             #(= :ok (first %))))\n\n  (go (println (<! (foo 0)))\n    (println (<! (foo 0)))\n    (println (<! (foo 1)))\n    (println (<! (foo 1))))\n  ~~~\n  "],"~$safe-parallel",["^ ","^L",null,"^M",["^ ","^N","^>","^O",172,"^P",7,"^Q",172,"^R",20,"^S",["^T",["^U",["^T",[["~$chans"]]]]],"^W","Receives a sequence of channels and fail-test function and returns a channel which will receive\n  a sequence with the result of all the channels or with error if one of the channels failed.\n  Data is read from the channels in parallel.\n  if one of the channels failed - according to the fail-test function the result is the error message\n  in other case the result is a sequence where each element in the sequence is the result\n  of the corresponding channel in the sequence."],"^=","~$gadjett.async-utils/safe-parallel","^Y",false,"^N","gadjett/async_utils.cljc","^R",20,"^Z",["^T",[["^14"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",172,"^Q",172,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["^14"]]]]],"^W","Receives a sequence of channels and fail-test function and returns a channel which will receive\n  a sequence with the result of all the channels or with error if one of the channels failed.\n  Data is read from the channels in parallel.\n  if one of the channels failed - according to the fail-test function the result is the error message\n  in other case the result is a sequence where each element in the sequence is the result\n  of the corresponding channel in the sequence."],"~$vec->map",["^ ","^L",null,"^M",["^ ","^N","^>","^O",103,"^P",8,"^Q",103,"^R",16,"~:private",true,"^S",["^T",["^U",["^T",[["~$vec"]]]]]],"^17",true,"^=","~$gadjett.async-utils/vec->map","^Y",false,"^N","gadjett/async_utils.cljc","^R",16,"^Z",["^T",[["^18"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",103,"^Q",103,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["^18"]]]]]],"~$wait-for-msg",["^ ","^L",null,"^M",["^ ","^N","^>","^O",134,"^P",7,"^Q",134,"^R",19,"^S",["^T",["^U",["^T",[["~$c","~$msg"]]]]]],"^=","~$gadjett.async-utils/wait-for-msg","^Y",false,"^N","gadjett/async_utils.cljc","^R",19,"^Z",["^T",[["~$c","^1;"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",134,"^Q",134,"^11",2,"^12",true,"^S",["^T",["^U",["^T",[["~$c","^1;"]]]]]],"~$go-map",["^ ","^L",null,"^M",["^ ","^N","^>","^O",76,"^P",7,"^Q",76,"^R",13,"^S",["^T",["^U",["^T",[["~$f","~$coll"]]]]],"^W","\n  Usage: `(go-map f coll)`\n\n  Returns a channel that will receive the result of `f` applied to \n  each item of `coll` once all the data is available.\n  The calculations are done in parallel.\n  \n  ~~~klipse\n  \n    (defn async-square [x]\n      (go\n        (* x x)))\n\n    (go (println (<! (go-map async-square [1 2 3]))))\n  ~~~\n  "],"^=","~$gadjett.async-utils/go-map","^Y",false,"^N","gadjett/async_utils.cljc","^R",13,"^Z",["^T",[["~$f","^1>"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",76,"^Q",76,"^11",2,"^12",true,"^S",["^T",["^U",["^T",[["~$f","^1>"]]]]],"^W","\n  Usage: `(go-map f coll)`\n\n  Returns a channel that will receive the result of `f` applied to \n  each item of `coll` once all the data is available.\n  The calculations are done in parallel.\n  \n  ~~~klipse\n  \n    (defn async-square [x]\n      (go\n        (* x x)))\n\n    (go (println (<! (go-map async-square [1 2 3]))))\n  ~~~\n  "],"~$aaaa-load-ns",["^ ","^L",null,"^M",["^ ","^N","^>","^O",13,"^P",7,"^Q",13,"^R",19,"^S",["^T",["^U",["^T",[[]]]]],"^W","\n  ~~~klipse\n  (require '[clojure.core.async :refer [<!]])\n  (require-macros '[cljs.core.async.macros :refer [go go-loop]])  \n  (require '[gadjett.async-utils :refer [safe-memoize-async memoize-async go-map go-map-object go-seq->map wait-for-msg wait-for-condition parallel safe-parallel safe-serial]])\n  ~~~\n  "],"^=","~$gadjett.async-utils/aaaa-load-ns","^Y",false,"^N","gadjett/async_utils.cljc","^R",19,"^Z",["^T",[[]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",13,"^Q",13,"^11",0,"^12",true,"^S",["^T",["^U",["^T",[[]]]]],"^W","\n  ~~~klipse\n  (require '[clojure.core.async :refer [<!]])\n  (require-macros '[cljs.core.async.macros :refer [go go-loop]])  \n  (require '[gadjett.async-utils :refer [safe-memoize-async memoize-async go-map go-map-object go-seq->map wait-for-msg wait-for-condition parallel safe-parallel safe-serial]])\n  ~~~\n  "],"~$wait-for-condition",["^ ","^L",null,"^M",["^ ","^N","^>","^O",140,"^P",7,"^Q",140,"^R",25,"^S",["^T",["^U",["^T",[["~$f","~$interval-in-msec"]]]]],"^W","\n  returns a channel that will be activated when the predicate `f` returns true.\n  \n  ~~~klipse\n  (let [start (js/Date.)]\n  (go \n    (println \"start:\" (js/Date.))\n    (<! (wait-for-condition #(>= (- (js/Date.) start) 1000) 100))\n    (println \"done:\" (js/Date.))))\n  ~~~\n  "],"^=","~$gadjett.async-utils/wait-for-condition","^Y",false,"^N","gadjett/async_utils.cljc","^R",25,"^Z",["^T",[["~$f","^1C"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",140,"^Q",140,"^11",2,"^12",true,"^S",["^T",["^U",["^T",[["~$f","^1C"]]]]],"^W","\n  returns a channel that will be activated when the predicate `f` returns true.\n  \n  ~~~klipse\n  (let [start (js/Date.)]\n  (go \n    (println \"start:\" (js/Date.))\n    (<! (wait-for-condition #(>= (- (js/Date.) start) 1000) 100))\n    (println \"done:\" (js/Date.))))\n  ~~~\n  "],"~$parallel",["^ ","^L",null,"^M",["^ ","^N","^>","^O",158,"^P",7,"^Q",158,"^R",15,"^S",["^T",["^U",["^T",[["^14"]]]]],"^W","Receives a sequence of channels and returns a channel which will receive\n  a sequence with the result of all the channels.\n  Data is read from the channels in parallel.\n  The result is a sequence where each element in the sequence is the result\n  of the corresponding channel in the sequence."],"^=","~$gadjett.async-utils/parallel","^Y",false,"^N","gadjett/async_utils.cljc","^R",15,"^Z",["^T",[["^14"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",158,"^Q",158,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["^14"]]]]],"^W","Receives a sequence of channels and returns a channel which will receive\n  a sequence with the result of all the channels.\n  Data is read from the channels in parallel.\n  The result is a sequence where each element in the sequence is the result\n  of the corresponding channel in the sequence."],"~$go-map-object",["^ ","^L",null,"^M",["^ ","^N","^>","^O",109,"^P",7,"^Q",109,"^R",20,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^W","Usage: `(go-map-object f m)`\n\n  Returns channel that will receive a map with the same keys as `m` and with the values transformed by `f`.\n  Where `f` is an asynchronous function.\n\n  ~~~klipse\n\n    (defn async-square [x]\n      (go\n        (* x x)))\n\n    (go (println (<!\n     (go-map-object async-square {:a 1 :b 2}))))\n  ~~~\n\n  "],"^=","~$gadjett.async-utils/go-map-object","^Y",false,"^N","gadjett/async_utils.cljc","^R",20,"^Z",["^T",[["~$f","~$m"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",109,"^Q",109,"^11",2,"^12",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^W","Usage: `(go-map-object f m)`\n\n  Returns channel that will receive a map with the same keys as `m` and with the values transformed by `f`.\n  Where `f` is an asynchronous function.\n\n  ~~~klipse\n\n    (defn async-square [x]\n      (go\n        (* x x)))\n\n    (go (println (<!\n     (go-map-object async-square {:a 1 :b 2}))))\n  ~~~\n\n  "],"~$memoize-async",["^ ","^L",null,"^M",["^ ","^N","^>","^O",55,"^P",7,"^Q",55,"^R",20,"^S",["^T",["^U",["^T",[["~$f"]]]]],"^W","\n  Usage: `(memoize-async f)`\n\n\n  Same as [clojure.core.memoize](https://clojuredocs.org/clojure.core/memoize)  for asynchronous functions (e.g. functions that return a `chan`).\n  Returns a channel with the memoized result of the function call.\n\n  ~~~klipse\n  \n    (defn async-square [x]\n      (go\n        (* x x)))\n  \n    (go (println (<! ((memoize-async async-square) 4))))\n  ~~~\n  "],"^=","~$gadjett.async-utils/memoize-async","^Y",false,"^N","gadjett/async_utils.cljc","^R",20,"^Z",["^T",[["~$f"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",55,"^Q",55,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["~$f"]]]]],"^W","\n  Usage: `(memoize-async f)`\n\n\n  Same as [clojure.core.memoize](https://clojuredocs.org/clojure.core/memoize)  for asynchronous functions (e.g. functions that return a `chan`).\n  Returns a channel with the memoized result of the function call.\n\n  ~~~klipse\n  \n    (defn async-square [x]\n      (go\n        (* x x)))\n  \n    (go (println (<! ((memoize-async async-square) 4))))\n  ~~~\n  "],"~$safe-serial",["^ ","^L",null,"^M",["^ ","^N","^>","^O",193,"^P",7,"^Q",193,"^R",18,"^S",["^T",["^U",["^T",[["~$functions"]]]]],"^W","Receives a vector of {:f-name name :f-deps dependent-functions :f async-function}, and runs the functions one after the other. Each function is called with the result of its dependent functnios.\n  Returns a channel with the result of all the functions, or with an error if one of the functions failed."],"^=","~$gadjett.async-utils/safe-serial","^Y",false,"^N","gadjett/async_utils.cljc","^R",18,"^Z",["^T",[["^1L"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",193,"^Q",193,"^11",1,"^12",true,"^S",["^T",["^U",["^T",[["^1L"]]]]],"^W","Receives a vector of {:f-name name :f-deps dependent-functions :f async-function}, and runs the functions one after the other. Each function is called with the result of its dependent functnios.\n  Returns a channel with the result of all the functions, or with an error if one of the functions failed."],"~$go-seq->map",["^ ","^L",null,"^M",["^ ","^N","^>","^O",130,"^P",7,"^Q",130,"^R",18,"^S",["^T",["^U",["^T",[["~$f","~$lst"]]]]]],"^=","~$gadjett.async-utils/go-seq->map","^Y",false,"^N","gadjett/async_utils.cljc","^R",18,"^Z",["^T",[["~$f","^1O"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",130,"^Q",130,"^11",2,"^12",true,"^S",["^T",["^U",["^T",[["~$f","^1O"]]]]]],"~$go-map-2d-vec",["^ ","^L",null,"^M",["^ ","^N","^>","^O",106,"^P",8,"^Q",106,"^R",21,"^17",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]]],"^17",true,"^=","~$gadjett.async-utils/go-map-2d-vec","^Y",false,"^N","gadjett/async_utils.cljc","^R",21,"^Z",["^T",[["~$f","~$m"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",106,"^Q",106,"^11",2,"^12",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]]],"~$select-vals-in-order",["^ ","^L",null,"^M",["^ ","^N","^>","^O",188,"^P",8,"^Q",188,"^R",28,"^17",true,"^S",["^T",["^U",["^T",[["~$map","~$ks"]]]]],"^W","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^17",true,"^=","~$gadjett.async-utils/select-vals-in-order","^Y",false,"^N","gadjett/async_utils.cljc","^R",28,"^Z",["^T",[["^1T","^1U"]]],"^[",null,"^10",["^T",[null,null]],"^P",1,"^O",188,"^Q",188,"^11",2,"^12",true,"^S",["^T",["^U",["^T",[["^1T","^1U"]]]]],"^W","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"]],"~:require-macros",["^ ","^9","^9"],"~:cljs.analyzer/constants",["^ ","~:seen",["^<",["^1P","^1V","~:f-deps","^K","^1T","^13","^1F","^17","~:else","^16","^1R","~:ns","^=","^1J","^1O","^N","^1:","^R","^1=","^X","^1@","~:recur","^1B","^18","^1M","^1U","~:f-name","^1C","^1E","^P","^19","^1G","~$m","^1L","^14","^1I","^1>","^>","^1<","^O","^1?","^15","^1;","~:ok","^1K","^Q","^V","^1N","~$c","~:f","~:error","^1Q","^S","^1A","^1D","^1S","^W","~:test","~$f","^1H"]],"~:order",["^1A","^20","^=","^N","^R","^P","^O","^Q","^S","^W","^25","^>","^1@","^21","^1[","^X","^K","~$f","^V","^1J","^1I","^1?","^1=","^1>","^19","^17","^16","^18","^1R","^1Q","~$m","^1H","^1G","^1P","^1N","^1O","^1<","^1:","~$c","^1;","^1D","^1B","^1C","^1F","^1E","^14","^23","^24","^15","^13","^1V","^1S","^1T","^1U","~:f","^1Z","^22","^1M","^1K","^1L"]],"^W",null]