<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>gadjett.async-utils documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" /><div style="visibility: hidden;"><div class="klipse" data-external-libs="src">(ns test.gadjett
                                                         (:require
                                                         [gadjett.linear :as glinear :refer [intersection-point-func linear-equation intersection-point find-below-and-above-y linear-equation-func highest-below-x linear-y linear-x-func log-x-intersection-point interpolate-linear-y linear-y-func intersection-point-from-2-lines-points lowest-above-x find-keys-with-value log-x-linear-y lowest-above-y log-x-linear-equation calc-interpolated-values linear-x interpolate-linear-x below-and-above-y highest-below-y find-keys-with-values-in]]
                                                         [gadjett.collections :as gcoll :refer [compact unflatten-keys sequence-&gt;map sequence-of-maps-&gt;map =without-keys? dissoc-in split-by-predicate-positions mapify submap? positions filter-map vec-&gt;map assoc-cyclic infinity subsequence edn-zip fix-blank-lines map-nested-vals map-to-object deep-merge deep-merge-with mean map-object-kv flatten-keys flatten-keys* compactize-map compactize-map-recursive partition-between take-from-map map-with-index map-object-with-key deep-merge* range-till-end nearest-of-seq branches-and-leaves remove-ending-comments remove-blank-lines filter-branches out-of-bound? map-2d-vec split-by-predicate collify abs append-cyclic map-2d-vec-kv max-and-min index-of nearest-of-ss map-reverse-hierarchy map-object my-replace join-them]]))</div></div><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Gadjett</span> <span class="project-version">0.5.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>gadjett</span></div></div></li><li class="depth-2 branch current"><a href="gadjett.async-utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async-utils</span></div></a></li><li class="depth-2 branch"><a href="gadjett.collections.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>collections</span></div></a></li><li class="depth-2 branch"><a href="gadjett.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="gadjett.core-fn.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-fn</span></div></a></li><li class="depth-2 branch"><a href="gadjett.linear.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>linear</span></div></a></li><li class="depth-2"><a href="gadjett.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="gadjett.async-utils.html#var-aaaa-load-ns"><div class="inner"><span>aaaa-load-ns</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-go-map"><div class="inner"><span>go-map</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-go-map-object"><div class="inner"><span>go-map-object</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-go-seq-.3Emap"><div class="inner"><span>go-seq-&gt;map</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-memoize-async"><div class="inner"><span>memoize-async</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-parallel"><div class="inner"><span>parallel</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-safe-memoize-async"><div class="inner"><span>safe-memoize-async</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-safe-parallel"><div class="inner"><span>safe-parallel</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-safe-serial"><div class="inner"><span>safe-serial</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-wait-for-condition"><div class="inner"><span>wait-for-condition</span></div></a></li><li class="depth-1"><a href="gadjett.async-utils.html#var-wait-for-msg"><div class="inner"><span>wait-for-msg</span></div></a></li></ul></div><div class="namespace-docs" id="content"><p id="klipse-loader-wrapper">Click <a id="klipse-loader" href="javascript:void(0)">here</a> to make these examples interactive with ClojureScript.</p><h1 class="anchor" id="top">gadjett.async-utils</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-aaaa-load-ns"><h3>aaaa-load-ns</h3><div class="usage"><code>(aaaa-load-ns)</code></div><div class="doc"><div class="markdown"><pre><code class="klipse">(require '[clojure.core.async :refer [&lt;!]])
(require-macros '[cljs.core.async.macros :refer [go go-loop]])  
(require '[gadjett.async-utils :refer [safe-memoize-async memoize-async go-map go-map-object go-seq-&gt;map wait-for-msg wait-for-condition parallel safe-parallel safe-serial]])
</code></pre></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L13">view source</a></div></div><div class="public anchor" id="var-go-map"><h3>go-map</h3><div class="usage"><code>(go-map f coll)</code></div><div class="doc"><div class="markdown"><p>Usage: <code>(go-map f coll)</code></p>
<p>Returns a channel that will receive the result of <code>f</code> applied to each item of <code>coll</code> once all the data is available. The calculations are done in parallel.</p>
<pre><code class="klipse"><br />  (defn async-square [x]
    (go
      (* x x)))

  (go (println (&lt;! (go-map async-square [1 2 3]))))
</code></pre></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L76">view source</a></div></div><div class="public anchor" id="var-go-map-object"><h3>go-map-object</h3><div class="usage"><code>(go-map-object f m)</code></div><div class="doc"><div class="markdown"><p>Usage: <code>(go-map-object f m)</code></p>
<p>Returns channel that will receive a map with the same keys as <code>m</code> and with the values transformed by <code>f</code>. Where <code>f</code> is an asynchronous function.</p>
<pre><code class="klipse"><br />  (defn async-square [x]
    (go
      (* x x)))

  (go (println (&lt;!
   (go-map-object async-square {:a 1 :b 2}))))
</code></pre></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L109">view source</a></div></div><div class="public anchor" id="var-go-seq-.3Emap"><h3>go-seq-&gt;map</h3><div class="usage"><code>(go-seq-&gt;map f lst)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L130">view source</a></div></div><div class="public anchor" id="var-memoize-async"><h3>memoize-async</h3><div class="usage"><code>(memoize-async f)</code></div><div class="doc"><div class="markdown"><p>Usage: <code>(memoize-async f)</code></p>
<p>Same as <a href="https://clojuredocs.org/clojure.core/memoize">clojure.core.memoize</a> for asynchronous functions (e.g. functions that return a <code>chan</code>). Returns a channel with the memoized result of the function call.</p>
<pre><code class="klipse"><br />  (defn async-square [x]
    (go
      (* x x)))

  (go (println (&lt;! ((memoize-async async-square) 4))))
</code></pre></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L55">view source</a></div></div><div class="public anchor" id="var-parallel"><h3>parallel</h3><div class="usage"><code>(parallel chans)</code></div><div class="doc"><div class="markdown"><p>Receives a sequence of channels and returns a channel which will receive a sequence with the result of all the channels. Data is read from the channels in parallel. The result is a sequence where each element in the sequence is the result of the corresponding channel in the sequence.</p></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L158">view source</a></div></div><div class="public anchor" id="var-safe-memoize-async"><h3>safe-memoize-async</h3><div class="usage"><code>(safe-memoize-async f success-test-fn)</code></div><div class="doc"><div class="markdown"><p>Usage: <code>(safe-memoize-async f success-test-fn)</code></p>
<p>Same as memoize-async, but will only memoize the result if it passes the <code>success-test-fn</code>.</p>
<pre><code class="klipse">(def foo (safe-memoize-async (fn [x]
                             (go
                               (println "running the function with: " x)
                               (if (zero? x)
                                 [:error]
                                 [:ok x])))
                           #(= :ok (first %))))

(go (println (&lt;! (foo 0)))
  (println (&lt;! (foo 0)))
  (println (&lt;! (foo 1)))
  (println (&lt;! (foo 1))))
</code></pre></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L23">view source</a></div></div><div class="public anchor" id="var-safe-parallel"><h3>safe-parallel</h3><div class="usage"><code>(safe-parallel chans)</code></div><div class="doc"><div class="markdown"><p>Receives a sequence of channels and fail-test function and returns a channel which will receive a sequence with the result of all the channels or with error if one of the channels failed. Data is read from the channels in parallel. if one of the channels failed - according to the fail-test function the result is the error message in other case the result is a sequence where each element in the sequence is the result of the corresponding channel in the sequence.</p></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L172">view source</a></div></div><div class="public anchor" id="var-safe-serial"><h3>safe-serial</h3><div class="usage"><code>(safe-serial functions)</code></div><div class="doc"><div class="markdown"><p>Receives a vector of {:f-name name :f-deps dependent-functions :f async-function}, and runs the functions one after the other. Each function is called with the result of its dependent functnios. Returns a channel with the result of all the functions, or with an error if one of the functions failed.</p></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L193">view source</a></div></div><div class="public anchor" id="var-wait-for-condition"><h3>wait-for-condition</h3><div class="usage"><code>(wait-for-condition f interval-in-msec)</code></div><div class="doc"><div class="markdown"><p>returns a channel that will be activated when the predicate <code>f</code> returns true.</p>
<pre><code class="klipse">(let [start (js/Date.)]
(go 
  (println "start:" (js/Date.))
  (&lt;! (wait-for-condition #(&gt;= (- (js/Date.) start) 1000) 100))
  (println "done:" (js/Date.))))
</code></pre></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L140">view source</a></div></div><div class="public anchor" id="var-wait-for-msg"><h3>wait-for-msg</h3><div class="usage"><code>(wait-for-msg c msg)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/viebel/gadjett/blob/master/src/gadjett/async_utils.cljc#L134">view source</a></div></div></div><script>window.klipse_settings = {
    selector: '.klipse,.klipse',
    codemirror_options_in: {
    lineWrapping: true,
    autoCloseBrackets: true
    },
    codemirror_options_out: {
    lineWrapping: true
    },
    };

    if (/gadjett\..*|cljs\..*/) { window.klipse_settings.clojure_cached_macro_ns_regexp =  /gadjett\..*|cljs\..*/;}
if (/gadjett\..*|cljs\..*/) { window.klipse_settings.clojure_cached_ns_regexp =  /gadjett\..*|cljs\..*/;}
if (/gadjett\..*/) { window.klipse_settings.clojure_bundled_ns_ignore_regexp =  /gadjett\..*/;}
if ('./cache-cljs') { window.klipse_settings.cached_ns_root =  './cache-cljs';}
</script><script>
    function klipseLocalStorageEnabled() {
        var mod = 'modernizr';
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (e) {
          return false;
        }
     }
     function klipseLoad() {
      if (klipseLocalStorageEnabled()) { sessionStorage.setItem('klipse', true);}
      $('#klipse-loader-wrapper').remove();
      var s = document.createElement('script');
      s.setAttribute('src','https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js');
      document.head.appendChild(s);
      }
    if(!false) {
      klipseLoad();
    } else {
      if((klipseLocalStorageEnabled() && sessionStorage.getItem('klipse')) || window.location.search.match(/klipse=1/)) {
        klipseLoad();
      } else {
        $('#klipse-loader').click(function(){
        klipseLoad();
       });
      }
    }
    </script></body></html>